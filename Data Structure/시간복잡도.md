
# 시간복잡도

- 가상컴퓨터에서 가상언어로 작성된 가상코드를 실행(시뮬레이션)한다고 가정한다.
- 특정 입력에 대해 수행되는 알고리즘의 기본연산(primitive operation)의 횟수로 수행시간을 정의한다.
- 문제는 입력의 종류가 무한하므로 모든 입력에 대해 수행시간을 측정하여 평균을 구하는 것은 현실적으로 가능하지 않다는 점이다.
- 따라서 **최악의 경우의 입력(worst-case input)을 가정하여, 최악의 경우의 입력에 대한 알고리즘의 수행시간을 측정**한다.

## ✅ Checkpoint

- **알고리즘의 수행시간 = 최악의 경우의 입력에 대한 기본연산의 수행 횟수**
- 최악의 경우의 수행시간은 입력의 크기`(n)` 에 대한 함수 `T(n)`으로 표기된다.
- T(n)의 수행시간을 갖는 알고리즘은 어떠한 입력에 대해서도 T(n) 시간 이내에 종료됨을 보장한다.
    - 어떤 입력에 대해서도 worst-case time complexity 보다 수행시간이 크지 않기 때문
    - 실시간 제어가 필요하고 절대 안전이 요구되는 분야(항공, 교통, 위성, 원자로 제어 등)에선 실제로 최악의 경우를 가정한 알고리즘 설계가 필요하기 때문에 유효한 수행시간 측정방법이다.
- **최악의 경우의 입력에 대해 알고리즘의 기본연산(복사, 산술, 비교, 논리, 비트논리)의 횟수를 센다.**
### Algorithm 1) n개의 정수 중 최댓값을 찾는 알고리즘



### Algorithm 2)



### Algorithm 3)


---

## 간단 표기법(Big-O)

- 최악의 입력에 대한 기본연산의 횟수를 정확히 세는 건 일반적으로 귀찮고 까다롭다.
- 정확한 횟수보다는 입력의 크기 n이 커질 때, 수행시간의 증가하는 정도(rate of the growth of T(n) as n goes big)가 훨씬 중요하다.
- 수행시간 함수 T(n)이 n에 관한 여러 항(term)의 합으로 표현된다면, **함수 값의 증가율이 가장 큰 항 하나로 간략히 표기**하는 게 시간 분석을 간단하게 하는 데 큰 도움이 된다.
    - 예를 들어, `T(n) = 2n + 5` 이면, 상수항보다는 n의 일차항이 T(n)의 값을 결정하게 되므로 상수항을 생략해도 큰 문제가 없다.
    - `T(n) = 3n^2 + 12n -6` 이면, n 값이 커짐에 따라 `n^2` 항이 T(n)의 값을 결정하게 되므로, 일차항과 상수항을 생략해도 큰 문제가 없다.
- 이렇게 최고차 항만을 남기고 나머지는 생략하는 식으로 수행시간을 간략히 표기하는 방법을 **근사적 표기법**(Asymptotic Notation)이라고 부르고, **Big-O**를 이용하여 다음의 예처럼 표기한다.
    - `T(n) = 2n + 5 → T(n) = O(n)`
    - `T(n) = 3n^2 + 12n - 6 → T(n) = O(n^2)`
- Big-O를 표기하기 위한 방법은 다음과 같다.
    1. `n` 이 증가할 때 가장 빨리 증가하는 항(최고차 항)만 남기고 다른 항은 모두 생략한다.
    2. 가장 빨리 증가하는 항에 곱해진 상수 역시 생략한다.
    3. 남은 항을 `O( )` 안에 넣어 표기한다.




### O(1) 시간 알고리즘 : constant time algorithm

- 값을 1 증가시킨 후 리턴

```python
def increment_one(a):
	return a+1

'''
T(n) = 1
최고차항은 O(n^0) -> O(1)
'''
```

### O(log n) 시간 알고리즘 : logarithmic time algorithm

- log의 밑은 2라고 가정: n을 이진수로 표현했을 때의 비트수 계산 알고리즘

```python
def number_of_bits(n):
	count = 0
	while n > 0:
		n = n // 2 # 정수 나눗셈 (나머지를 없애고 몫만 표현)
		count += 1
	return count

'''
while문을 돌 때마다
n = 8 -> 4 -> 2 -> 1, 0이 되면 loop를 빠져나온다.
이 때, count는 1씩 증가하므로 3이 리턴된다.

n = 8 -> n/2 -> n/2^2 -> ... -> n/2^(count), 0이 되면 loop를 빠져나온다.
빠져나오면 count가 리턴된다.
'''
```


### O(n) 시간 알고리즘: linear time algorithm

- n에 대해 선형적으로 증가
- n개의 수 중에서 최댓값 찾는 알고리즘

### O(n^2) 시간 알고리즘: quadratic time algorithm

- n에 대해 제곱으로 증가
- 두 배열 A, B의 모든 정수 쌍의 곱의 합을 계산하는 알고리즘

```python
# pseudo code
algorithm array_sum(A, B, n):
  sum = 0
  for i = 0 to n - 1 do
	for j = 0 to n - 1 do
	  sum += A[i]*B[j]
  return sum
end_algorithm
```

### O(n^3) 시간 알고리즘: cubic time algorithm

- n X n 인 2차원 행렬 A와 B의 곱을 계산하여 결과 행렬 C를 리턴하는 알고리즘

```python
# pseudo code
algorithm mult_matrices(A, B, n)
  input: n x n 2d matrices A, B
  output: C = A x B
  
  for i = 1 to n do
	for j = 1 to n do
	  C[i][j] = 0
  for i = 1 to n do
	for j = 1 to n do
	  for k = 1 to n do
		C[i][j] += A[i][k] * B[k][j]
  return C
end_of_algorithm
```

### O(2^n) 이상의 시간이 필요한 알고리즘: exponential time algorithm

- k번째 피보나치 수 계산하는 알고리즘

```python
def fibonacci(k):
	if k <= 1: return k
	return fibonacci(k-1) + fibonacci(k-2)
```

### **Know Thy Complexities!**

출처 : [https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)

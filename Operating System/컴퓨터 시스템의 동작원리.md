# 1. 컴퓨터 시스템의 구조

## 컴퓨터 내부장치와 외부장치 구조

- 컴퓨터 내부장치 → CPU, 메모리
- 컴퓨터 외부장치 → 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등
- 컴퓨터는 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 그 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다.
- 컨트롤러
    - 메모리 및 입출력장치 등의 각 하드웨어 장치를 제어하는 일종의 작은 CPU
    - 로컬버퍼 : 각 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리
- 커널 : 항상 메모리에 올라가 있는 운영체제 중에서 핵심적인 부분

# 2. CPU 연산과 I/O 연산

- 입출력 장치들의 I/O 연산은 입출력 컨트롤러가 담당하고, 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당한다.
- 기본적으로 CPU는 매 시점 메모리에서 명령(instruction)을 하나씩 읽어와서 수행한다.
- 이때 CPU 옆에는 인터럽트 라인(interrupt line)이 있어서, CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지 확인한다.

# 3. 인터럽트의 일반적 기능

## 인터럽트

- 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법
- 키보드 입력 혹은 요청된 디스크 입출력 작업의 완료 등 CPU에 알려줄 필요가 있는 이벤트가 일어난 경우 컨트롤러가 발생시킨다.
- 인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

## 인터럽트 종류

- 하드웨어 인터럽트(Interrupt): 하드웨어가 발생시킨 인터럽트
- 소프트웨어 인터럽트(Trap)
    - 예외상황(Exception)
        - 프로그램이 오류를 범한 경우
        - ex) 사용자 프로그램이 0으로 나누는 연산 등 비정상적인 작업 시도, 권한 없는 작업 시도할 때
    - 시스템 콜(System call)
        - 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법
        - 즉, 프로그램이 커널 함수를 호출하는 경우
- 차이점
    - 하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅한다.
    - 반면, 소프트웨어 인터럽트는 소프트웨어가 그 일을 수행한다.
- 공통점
    - CPU의 서비스가 필요한 경우, CPU 옆에 있는 인터럽트 라인에 신호를 보내서 인터럽트가 발생했음을 알린다.
    - 인터럽트가 발생하면 CPU는 하던 일을 멈추고 운영체제 커널 내에서 해당 인터럽트의 처리를 위해 정의된 코드를 찾는다.

## 운영체제가 할 일을 찾아가는 법

### 인터럽트 벡터(Interrupt vector)

- 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조
- 해당 인터럽트 처리루틴 주소를 가지고 있다.

### 인터럽트 처리루틴(Interrupt Service Routine)

- 운영체제 커널 내에 있는 인터럽트 처리루틴은 다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의하고 있다.
- 해당 인터럽트를 처리하는 커널 함수
- 인터럽트 핸들러라고도 불린다.

# 4. 인터럽트 핸들링

- 인터럽트가 발생한 경우에 처리해야 할 일의 절차
- 프로세스 제어블록(Process Control Block: PCB)
    - 운영체제가 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위한 자료구조
    - 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행 중이었는지를 저장한다.
    - 프로그램이 실행 중이던 코드의 메모리 주소와 레지스터값, 하드웨어 상태 등이 저장된다.

# 5. 입출력 구조

## 입출력(I/O)

- 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것

### 동기식 입출력(synchronous I/O)

- I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어간다.
- 구현 방법 1
    - I/O가 끝날 때까지 CPU를 낭비시킨다.
    - 메 시점 하나의 I/O만 일어날 수 있다.
- 구현 방법 2
    - I/O가 완료될 떄까지 해당 프로그램에게서 CPU를 뺴앗는다.
    - I/O 처리를 기다리는 중에 그 프로그램을 줄 세운다.
        - 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다.
    - 다른 프로그램에게 CPU를 준다.

### 비동기식 입출력(asynchronous I/O)

- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어간다.
- 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다.

# 6. DMA(Direct Memory Access)

- 원칙적으로 메모리는 CPU에 의해서만 접근할 수 있는 장치이다.

  ⇒ CPU 사용의 효율성이 떨어지는 문제 발생

  ⇒ 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU의 업무가 방해받기 때문

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송한다.
- 바이트 단위가 아니라 블록(block)이라는 큰 단위로 정보를 메모리로 읽어온 후, 인터럽트를 발생시킨다.

# 7. 저장장치의 구조

## 주기억장치

- 메모리
- 전원이 나가면 저장되었던 내용이 모두 사라져버리는 휘발성의 RAM을 매체로 사용하는 경우가 대부분

## 보조기억장치

- 전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성의 마그네틱 디스크를 주로 사용한다.
- 플래시 메모리, CD, 마그네틱 테이프 등

### 용도

- 파일 시스템(file system)용
    - 메모리는 휘발성 매체이기 때문에 비휘바렁 매체인 디스크를 파일 시스템용으로 사용한다.
- 스왑 영역(swap area)용
    - 운영체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓는다. ⇒ 스왑 아웃(swap out)
    - 스왑 영역으로는 하드디스크가 가장 널리 사용된다.
    - 스왑 영역은 프로그램이 실행될 때 내용을 저장했다가 프로그램이 종료될 때 삭제하는 메모리의 연장 공간으로서의 역할을 담당하므로, 파일 시스템처럼 비휘발성 용도로 사용되는 것과 역할이 구분된다.

# 8. 저장장치의 계층 구조

- 빠른 저장장치부터 느린 저장장치까지 단계적인 계층 구조로 이루어진다.
- 상위 저장 장치 계층(Primary) ⇒ 휘발성 저장장치
    - CPU 내부에 존재하는 레지스터(register)
    - 캐시 메모리(cache memory)
    - 메인 메모리(main memory)
- Secondary ⇒ 전원이 나가도 지워지지 않는 비휘발성 저장장치
    - 마그네틱 디스크
    - 광디스크
    - 마그네틱 테이프
- 캐싱 기법
    - 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법
    - 상대적으로 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장하여 두 저장장치 사이의 속도를 완충시킨다.

# 9. 하드웨어의 보안

## 커널모드와 사용자모드

- 하드웨어적인 보안을 유지하기 위해 운영체제는 커널모드와 사용자모드를 지원한다.
- 커널모드(kernel mode, system mode)
    - 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드
    - 모든 종류의 명령을 다 실행할 수 있다.
- 사용자모드(user mode)
    - 일반 사용자 프로그램이 실행되며 제한적인 명령만 수행할 수 있다.

## Mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원

    > `1` 사용자모드 : 사용자 프로그램 수행
      `0` 커널 모드 : OS 코드 수행

- 사용자 프로그램이 수행되더가 하드웨어 접근 등 보안이 필요한 중요한 명령을 수행해야 할 경우에는 시스템 콜을 통해 운영체제가 대신해줄 것을 요청한다.
- **특권명령**
    - 보안을 해칠 수 있는 중요한 명령어는 커널 모드에서 운영체제에 의해서만 수행 가능한 **특권명령**으로 규정
    - 모든 입출력 명령은 특권명령으로 규정해서 사용자 프로그램이 직접 입출력 하는 것을 차단한다.


# 10. 메모리 보안
## 메모리 보호 기법

- 기준 레지스터와 한계 레지스터를 이용하여 프로그램이 접근하려는 메모리 부분이 합법적인지 확인한다.
- 기준 레지스터(base register)
    - 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리상의 가장 작은 주소를 보관한다.
- 한계 레지스터
    - 그 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관한다.
- 사용자 프로그램은 기준 레지스터에 있는 주소부터 기준 레지스터+한계 레지스터값 사이의 주소 영역에만 접근할 수 있다.
- 불법적인 메모리 접근시, 예외상황 발생한다.

# 11. CPU 보호

## Timer

- CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 운영체제가 사용하는 하드웨어
- 역할
    - 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킨다.
    - 시분할 시스템에서 현재 시간 계산
- 타이머는 매 클럭 틱(clock tick) 때마다 1씩 감소하고, 0이 되는 순간 인터럽트가 발생한다.

# 12. 시스템 콜을 이용한 입출력 수행

## 입출력(I/O)의 수행

- 사용자 프로그램은 어떻게 I/O를 하는가?
    - 시스템콜(system call)
        - 사용자 프로그램은 운영체제에게 I/O 요청
    - 사용자 프로그램이 시스템 콜을 할 경우 트랩 발생하여 CPU의 제어권이 운영체제로 넘어감
    - Trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
    - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
    - 올바른 I/O 요청인지 확인 후 I/O 수행
    - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김
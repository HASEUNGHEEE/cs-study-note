# 1. 프로그램의 구조와 인터럽트

## 프로그램의 주소 영역

- 프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다.
- 프로그램의 주소 영역은 크게 코드(code), 데이터(data), 스택(stack) 영역으로 구분된다.
- **코드 영역**
    - 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명렁(machine instruction) 형태로 변환되어 저장되는 부분
- **데이터 영역**
    - 전역 변수(global variable) 등 프로그램이 사용하는 데이터를 저장하는 부분
- **스택 영역**
    - 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간

## 인터럽트의 동작 원리

```
1) A라는 프로그램이 CPU를 할당받고 명령을 수행하는 중에 인터럽트가 발생하면
2) A는 현재 수행 중인 **명령의 위치를 저장**해놓는다.
3) 운영체제 내부 코드인 인터럽트 처리루틴으로 넘어가서 인터럽트를 처리한다
4) 다시 돌아와 A의 이전 작업 지점부터 수행을 이어간다.
```

- 일반적으로 프로그램 내에서 발생되는 함수 호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관한다.
- 반면, 인터럽트 때문에 CPU를 빼앗긴 위치는 운영체제가 관리하는 `프로세스 제어블록(PCB)`에 저장된다.
    - 인터럽트가 발생한 시점에서 그 프로그램의 어느 부분까지 수행했는지 저장한다.
    - 인터럽트 처리 후 프로세스 제어블록에 저장된 주소를 복원시켜 원래 수행하던 일을 재개한다.

# 2. 컴퓨터 시스템의 작동 개요

## 컴퓨터 시스템

- CPU는 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 실행한다.
- 이때 CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터(Program Counter: PC)라고 부른다.
- 즉 CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리한다.
- 일반적으로 프로그램 카운터는 항상 바로 다음 명령을 가리키게 되어 코드의 순차적인 수행이 이루어진다.
    - 예외) 조건문이나 반복문, 함수호출 등에 의한 주소 이동

> 🔍 커널모드(kernel mode) vs 사용자모드(user mode)

- 메모리에는 사용자 프로그램들과 운영체제가 같이 올라가 수행된다. 이때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다.
- `CPU가 커널모드에서 수행 중`
    - 프로그램 카운터가 메모리 주소 중 운영체제가 존재하는 부분을 가리키고 있을 때
    - 현재 운영체제의 코드를 수행 중
- `CPU가 시용자모드에서 수행 중`
    - 프로그램 카운터가 사용자 프로그램이 존재하는 메모리 위치를 가리키고 있을 때
    - 그 메모리 위치에 올라가 있는 사용자 프로그램이 수행 중

> 🔍 일반명령 vs 특권명령

- CPU가 수행하는 명령에는 **일반 명령**과 **특권 명령**이 있다.
- `일반명령`
    - 메모리에서 자료를 읽어와 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들
    - 모든 프로그램이 수행할 수 있는 명령
    - 모드비트(mode bit)가 1일 때
- `특권명령`
    - 보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치에 접근하는 명령
    - 커널모드에서 항상 운영체제에 의해서만 수행할 수 있도록 제한된다.
    - 모드비트(mode bit)가 0일 때

> 🔍 시스템 콜(system call)

- 사용자 프로그램이 스스로 특권명령을 수행할 수 없어서 운영체제에게 특권명령의 대행을 요청한다.
- 이와 같은 서비스 요청을 **시스템 콜**이라고 한다.
- 사용자 프로그램이 시스템 콜을 하게 되면 운영체제는 사용자 프로그램의 코드가 아닌 커널 영역에 정의된 시스템 콜 처리 코드를 수행한다.

> 🔍 인터럽트

- CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행 → 주변장치의 상태를 지속적으로 파악할 수 없다.
- 주변장치는 CPU의 도움이 필요할 때 인터럽트를 사용해 CPU에게 서비스를 요청한다.
- 인터럽트를 발생시키기 위해 주변장치는 인터럽트 라인(interrupt line)을 세팅하고, CPU는 매번 명령을 수행한 직후 인터럽트 라인을 체크해 서비스 요청이 들어왔는지 확인한다.
- 인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드를 수행한다.

# 3. 프로그램의 실행

- `프로그램이 실행(program execution)되고 있다`의 의미
    - 디스크에 존재하던 실행파일이 메모리에 적재된다
    - 프로그램이 CPU를 할당받고 명령(instruction)을 수행하고 있는 상태
- **실행 파일**이 **메모리**에 **적재**될 때
    - 실행 파일 전체가 메모리에 한꺼번에 올라가기보다는 일부분만 메모리에 올라가고 나머지는 **디스크**의 **특정 영역**에 내려가 있는 것이 일반적이다.
    - 여러 프로그램이 공유하는 메모리 공간을 효율적으로 사용하기 위해서!
    - 프로그램의 주소 공간 중 당장 CPU의 수행에 필요한 부분은 메모리에 올려놓고, 그렇지 않은 부분은 디스크 중 메모리의 연장 공간으로 사용되는 **스왑 영역**에 내려놓는 방식으로 운영된다.
- 프로세스의 주소 공간은 **코드**, **데이터**, **스택** 등으로 구성된다.
    - 실제 물리적 메모리의 주소와 독립적으로, 각 프로그램마다 이러한 주소 공간을 별도로 가진다.
    - 각 프로그램마다 독자적으로 존재하는 이런 주소 공간을 **가상 메모리(virtual memory) 또는 논리적 메모리(logical memory)** 라 부른다.

## 운영체제 커널의 주소 공간

- 운영체제도 하나의 프로그램이므로 운영체제 커널 역시 코드,데이터,스택의 주소 공간 구성을 갖는다.

### 커널의 코드 영역

- 운영체제의 기능이 **아랫단의 하드웨어 자원을 효율적으로 관리** + **윗단의 응용프로그램 및 사용자에게 편리한 서비스 제공**이므로
- CPU, 메모리 등의 **자원을 관리하기 위한 부분** + 사용자에게 **편리한 인터페이스를 제공하기 위한 부분**이 주를 이룬다.
- 이 밖에도 **시스템 콜** 및 **인터럽트를 처리하기 위한 부분**을 포함한다.

### 커널의 데이터 영역

- 각종 자원을 관리하기 위한 **자료구조**가 저장된다.
    - CPU, 메모리와 같은 하드웨어 자원을 관리하기 위한 자료구조
    - 현재 수행중인 프로그램을 관리하기 위한 자료구조
- 이 때, 현재 수행중인 프로그램을 **프로세스**라고 부른다.
- 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조 **PCB**가 존재한다.
- 즉, 하드웨어와 소프트웨어를 포함하는 **시스템 내의 모든 자원을 관리하기 위한 자료구조를 각각 유지**한다.

### 커널의 스택 영역

- 함수 호출시 복귀 주소를 저장하기 위한 용도로 사용된다.
- 커널의 스택은 일반 사용자 프로그램의 스택과 달리 현재 수행중인 프로세스마다 **별도의 스택**을 두어 관리한다.
    - ❓ 프로세스마다 별도의 스택을 두어 관리하는 이유

        ```
        1) 프로세스가 함수를 호출할 때 자기 주소 영역 내부에 정의된 함수를 호출하면 자신의 스택에 복귀 주소를 저장하지만,
        프로세스가 특권 명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우 
        그 복귀 주소는 커널 내의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장 공간이 필요하기 때문이다.
        
        2) 커널은 일종은 공유 코드로서 모든 사용자 프로그램이 시스템 콜을 통해 
        커널의 함수를 접근할 수 있으므로, 일관성 유지를 위해 각 프로세스마다 커널 내에 별도의 스택을 두게 된다.
        ```

- 즉, 프로그램이 실행되어 자기 자신의 코드 내에서 함수호출 및 복귀 주소를 유지하기 위해서는 **자기 주소 공간 내의 스택**을 사용하고, 시스템 콜이나 인터럽트 등으로 **커널 내의 함수**를 호출하는 경우에는 커널의 주소 공간에 존재하는 **커널스택**을 사용하게 된다.

# 4. 사용자 프로그램이 사용하는 함수

- 프로그램이 사용하는 함수는 크게 **사용자 정의함수와 라이브러리 함수, 커널함수**의 세 가지로 구분할 수 있다.
- `사용자 정의함수`와 `라이브러리 함수`
    - 사용자 정의 함수란 프로그래머가 직접 작성한 함수를 뜻한다.
    - 라이브러리 함수란 누군가가 작성해놓은 함수를 호출만 하여 사용하는 경우를 뜻한다.
    - 모두 그 프로그램의 코드 영역에 기계어 명령 형태로 존재한다.
    - 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함되며, 함수호출 시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.
- `커널함수`
    - 운영체제 커널의 코드에 정의된 함수를 뜻한다.
    - 종류
        - 사용자 프로그램이 운영체제의 서비스를 요청하기 위해 호출하는 **시스템 콜 함수**
        - 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 **인터럽트 처리 함수**
    - 운영체제 커널의 주소 공간에 코드가 정의된다. 즉, 운영체제 내에 있는 함수를 사용자 프로그램이 호출해서 사용하는 것이다.
    - 운영체제 내에는 시스템 콜 함수로 read() 함수와 write() 함수가 정의되어 있으며, 이들은 각각 사용자 프로그램이 입력과 출력을 필요로 할 때 호출하는 함수이다.
    - CPU를 운영체제에 넘기기 위해 시스템 콜은 인터럽트와 동일한 메커니즘, 즉 CPU의 인터럽트 라인을 세팅하는 방법을 사용한다.

# 5. 인터럽트

## 인터럽트 메커니즘

### 필요성

- CPU는 매번 프로그램 카운터가 가리키는 곳에 있는 명령을 수행하는 일밖에 하지 않는다.
- 따라서 현재 수행 중인 프로세스로부터 CPU를 회수해 CPU가 다른 일을 수행하도록 하기 위해서는 인터럽트 메커니즘이 필요하다.

### 메커니즘

```
1) CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행한다.
2) 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지 체크한다.
3) 인터럽트 라인 체크를 통해 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고, 운영체제의 인터럽트 처리루틴으로 이동해서 인터럽트 처리를 수행한다.
4) 인터럽트의 처리를 마치고 나면 인터럽트가 발생하기 지전의 프로세스에게 CPU의 제어권이 다시 넘어가게 된다.
```

<aside>
❓ 인터럽트 처리 중에 또 다른 인터럽트가 발생한다면?

</aside>

- 원칙적으로는 인터럽트 처리 중에 또 다른 인터럽트가 발생하는 것을 허용하지 않는다.
    - 인터럽트 처리 중에 다른 인터럽트를 처리하면 데이터의 일관성이 유지되지 않는 문제가 발생할 수 있기 때문!
- 하지만 인터럽트마다 중요도가 다르기 때문에 상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중에 중요도가 더 높은 인터럽트가 발생할 수 있다.
- 현재 처리 중인 인터럽트보다 더 높은 우선순위의 인터럽트가 발생한다면 현재 처리 중이던 인터럽트 코드의 수행 지점을 저장하고 우선순위가 높은 인터럽트를 처리한다.
- 인터럽트 처리가 끝나면 저장된 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행한다.

# 6. 시스템 콜

- 모든 프로그램은 자신의 독자적인 주소 공간을 가지고 있으며 ,프로그램이 함수호출을 하는 경우 자신의 주소 공간 내에서 호출이 이루어지게 된다.
- 그러나 **시스템 콜은 비록 함수 호출이긴 하지만 자신의 주소 공간을 거스르는 영역에 존재하는 함수를 호출**하는 것이다.
    - 자신의 프로그램이 아닌, `커널`이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 일이기 때문!
- 시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수호출과는 상이한 방법을 사용한다.
    - 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.
- 프로그램이 CPU를 할당받고 명령을 수행하다가 중간에 CPU를 빼앗기는 경우
    - **타이머에 의해 인터럽트가 발생하는 경우**
        - 타이머: 특정 프로그램에 의해 CPU가 독점되는 것을 방지하기 위한 하드웨어로, CPU 할당 시간이 만료되면 인터럽트를 발생시킨다.
        - 여러 프로세스가 CPU를 나누어 사용하는 시분할 시스템의 구현을 위한 필수적인 요소
    - **사용자 프로그램이 입출력 요청을 위해 시스템 콜을 하는 경우**
        - 오래 걸리는 입출력 작업이 완료되기까지 그 프로세스에게 CPU를 다시 할당하더라도 당장 다음 명령을 수행하지 못하는 경우가 일반적이므로 CPU를 다른 프로세스에게 이양하게 된다.
        - 입출력을 요청했던 프로세스는 입출력 요청이 완료되어 컨트롤러가 인터럽트를 발생시킨 시점부터 다시 CPU를 얻을 수 있는 기회가 생기며, CPU를 기다리는 큐에 삽입하여 CPU 할당을 기다린다.

# 7. 프로세스의 두 가지 실행 상태

- 하나의 프로세스가 시작되어 수행을 완료하기까지는 프로세스 자신의 주소 공간에 있는 코드만 실행되는 것이 아니라 커널의 주소 공간에 있는 코드도 실행된다.
- 이는 프로그램이 사용자 정의함수나 라이브러리 함수뿐 아니라 입출력 시스템 콜 등을 통해 **운영체제** **커널의 함수**도 호출하여 실행하기 때문이다.
- 프로그램이 시작되어 종료될 때까지 다양한 함수호출을 하며 실행되는데,이를 **사용자 모드**와 **커널 모드**의 실행 상태로 구분 지을 수 있다.
    - 프로그램이 사용자 정의 함수나 라이브러리 함수를 호출할 때에는 모드의 변경없이 사용자모드에서의 실행을 하게 되며,
    - 시스템 콜을 하는 경우에는 커널 모드로 진입해 커널의 주소 공간에 정의된 함수를 실행하게 된다.
    - 시스템 콜의 실행이 끝나면 다시 사용자 모드로 복귀해서 시스템 콜 이후의 명령들을 계속 실행하게 된다.
    - 프로그램의 실행이 끝날 때에는 커널 모드로 진입해 프로그램을 종료하게 된다.
- ex) 프로세스 A가 CPU에서 실행되고 있다
    - 자신의 주소 공간에 정의된 코드를 실행한다 → 사용자모드에서의 실행 상태(user mode running)
    - 커널의 시스템 콜 함수를 실행한다 → 커널모드에서의 실행 상태(kernel mode running)

> ⚠️ 주의할 점
- 시스템 콜을 통해 실행되는 것은 프로세스 A의 코드가 아닌 운영체제 커널의 코드이다.
- **하지만** 시스템 콜이 수행되는 동안 커널이 실행 상태(running state)에 있다고 하지 않고 **프로세스 A가 실행 상태에 있다고 말한다.**
- 커널의 코드가 실행되는 것이 사실상 프로세스 A가 해야 할 일을 대행하는 것이기 때문에 시스템 콜이 실행 주일 때에도 여전히 프로세스 A는 실행 상태에 있는 것으로 간주!
- 다만 프로세스 A 자신의 코드를 실행하는 것과 구분 지어, 이러한 상태를 `프로세스 A가 커널모드에서 실행중` 이라고 말한다.